author: Ir1d, CBW2007, ChungZH, xhn16729, Xeonacid, tptpp, hsfzLZH1, ouuan, TrisolarisHD, HeRaNO, greyqz, Chrogeek, partychicken

## 引入

???+note "[[IOI1994]数字三角形](https://www.luogu.com.cn/problem/P1216)"
    给定一个 $r$ 行的数字三角形（$r \leq 1000$），需要找到一条从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到当前点左下方的点或右下方的点。
    
    ```plain
            7 
          3   8 
        8   1   0 
      2   7   4   4 
    4   5   2   6   5 
    ```
    
    在上面这个例子中，最优路径是 $7 \to 3 \to 8 \to 7 \to 5$。

最简单粗暴的思路是尝试所有的路径。因为路径条数是 $O(2^r)$ 级别的，这样的做法无法接受。

注意到这样一个事实，一条最优的路径，它的每一步决策都是最优的。

以例题里提到的最优路径为例，只考虑前四步 $7 \to 3 \to 8 \to 7$，不存在一条从最顶端到 $4$ 行第 $2$ 个数的权值更大的路径。

而对于每一个点，它的下一步决策只有两种：往左下角或者往右下角（如果存在）。因此只需要记录当前点的最大权值，用这个最大权值执行下一步决策，来更新后续点的最大权值。

这样做还有一个好处：我们成功缩小了问题的规模，将一个问题分成了多个规模更小的问题。要想得到从顶端到第 $r$ 行的最优方案，只需要知道从顶端到第 $r-1$ 行的最优方案的信息就可以了。

这时候还存在一个问题：子问题间重叠的部分会有很多，同一个子问题可能会被重复访问多次，效率还是不高。解决这个问题的方法是把每个子问题的解存储下来，通过记忆化的方式限制访问顺序，确保每个子问题只被访问一次。

上面就是动态规划的一些基本思路。下面将会更系统地介绍动态规划的思想。

## 动态规划原理

能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。

### 最优子结构

具有最优子结构也可能是适合用贪心的方法求解。

注意要确保我们考察了最优解中用到的所有子问题。

1. 证明问题最优解的第一个组成部分是做出一个选择；
2. 对于一个给定问题，在其可能的第一步选择中，你界定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；
3. 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；
4. 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。

要保持子问题空间尽量简单，只在必要时扩展。

最优子结构的不同体现在两个方面：

1. 原问题的最优解中涉及多少个子问题；
2. 确定最优解使用哪些子问题时，需要考察多少种选择。

子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。

### 无后效性

已经求解的子问题，不会再受到后续决策的影响。

### 子问题重叠

如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。

### 基本思路

对于一个能用动态规划解决的问题，一般采用如下思路解决：

1. 将原问题划分为若干 **阶段**，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 **状态**）；
2. 寻找每一个状态的可能 **决策**，或者说是各状态间的相互转移方式（用数学的语言描述就是 **状态转移方程**）。
3. 按顺序求解每一个阶段的问题。

如果用图论的思想理解，我们建立一个 [有向无环图](../graph/dag.md)，每个状态对应图上一个节点，决策对应节点间的连边。这样问题就转变为了一个在 DAG 上寻找最长（短）路的问题。

## 最长公共子序列

???+note "最长公共子序列问题"
    给定两个长度为 $n$ 的序列 $A,B$（$n \leq 5000$），求出一个最长的序列，使得该序列既是 $A$ 的子序列，也是 $B$ 的子序列。

设 $f(i,j)$ 表示只考虑 $A$ 的前 $i$ 个元素，$B$ 的前 $j$ 个元素时的最长公共子序列的长度。则 $f(n,n)$ 即为所求结果。

对于每个 $f(i,j)$，存在三种决策：如果 $A_i=B_j$，则可以将它接到公共子序列的末尾；另外两种决策分别是跳过 $A_i$ 或者 $B_j$。

写成状态转移方程是这样的：

$$
f(i,j)= \max
\begin{cases}
 & f(i-1,j)\\ 
 & f(i,j-1)\\
 & f(i-1,j-1)+1 \text{ if } A_i = B_j
\end{cases}
$$

该做法的时间复杂度为 $O(n^2)$。

## 最长不下降子序列

???+note "最长不下降子序列问题"
    给定一个长度为 $n$ 的序列 $A$（$n \leq 5000$），求出一个最长的 $A$ 的子序列，满足该子序列的后一个元素不小于前一个元素。

### 算法一

设 $f(i)$ 表示以 $A_i$ 为结尾的最长不下降子序列的长度，则所求为 $\max_{1 \leq i \leq n} f(i)$。

计算 $f(i)$ 时，尝试将 $A_i$ 接到其他的最长不下降子序列后面，以更新答案。于是可以写出这样的状态转移方程：$f(i)=\max_{1 \leq j < i, A_j \leq A_i} (f(j)+1)$。

容易发现该算法的时间复杂度为 $O(n^2)$。

```cpp
int a[MAXN], d[MAXN];
int dp() {
  d[1] = 1;
  int ans = 1;
  for (int i = 2; i <= n; i++) {
    for (int j = 1; j < i; j++)
      if (a[j] <= a[i]) {
        d[i] = max(d[i], d[j] + 1);
        ans = max(ans, d[i]);
      }
  }
  return ans;
}
```

### 算法二[^ref1]

当 $n$ 的范围扩大到 $n \leq 10^5$ 时，第一种做法就不够快了，下面给出了一个 $O(n \log n)$ 的做法。

首先，定义 $a_1 \dots a_n$ 为原始序列， $d$ 为当前的不下降子序列， $len$ 为子序列的长度，那么 $d_{len}$ 就是长度为 $len$ 的不下降子序列末尾元素。

初始化： $d_1=a_1,len=1$ 。

现在我们已知最长的不下降子序列长度为 1，那么我们让 $i$ 从 2 到 $n$ 循环，依次求出前 $i$ 个元素的最长不下降子序列的长度，循环的时候我们只需要维护好 $d$ 这个数组还有 $len$ 就可以了。 **关键在于如何维护。** 

考虑进来一个元素 $a_i$ ：

1. 元素大于 $d_{len}$ ，直接 $d_{++len}=a_i$ 即可，这个比较好理解。
2. 元素等于 $d_{len}$ ，因为前面的元素都小于它，所以这个元素可以直接抛弃。
3. 元素小于 $d_{len}$ ，找到 **第一个** 大于它的元素，插入进去，其他小于它的元素不要。

参考代码如下：

```cpp
for (int i = 0; i < n; ++i) scanf("%d", a + i);
memset(dp, 0x1f, sizeof dp);
mx = dp[0];
for (int i = 0; i < n; ++i) {
  *std::upper_bound(dp, dp + n, a[i]) = a[i];
}
ans = 0;
while (dp[ans] != mx) ++ans;
```

### 最长回文子序列

$$
dp[i][i + len] =
\begin{cases}
dp[i + 1][i + len - 1] + 2,  & \text{if}\ s[i] = s[i + len] \\[2ex]
\max(dp[i + 1][i + len], dp[i][i + len - 1]), & \text{else}
\end{cases}
$$

边界： $dp[i][i] = 1$ 。

注意： $dp[i][j]$ 表示的是闭区间。

也可以转化为 LCS 问题，只需要把 $a$ 串反转当做 $b$ ，对 $a$ 和 $b$ 求 LCS 即可。

证明在 [这里](https://www.zhihu.com/question/34580085/answer/59539708) 。

注意区分子串（要求连续）的问题。

### 最长回文子串

 $O(n^2)$ ： $dp[i] = \max(dp[j] + 1), s(j + 1 \cdots i)$ 是回文

 $O(n)$ ：Manacher

 $p[i]$ 表示从 $i$ 向两侧延伸（当然要保证两侧对应位置相等）的最大长度。

为了处理方便，我们把原串每两个字符之间加一个（不包含在原串中的） `#` ，开头加一个 `$` 。

这样得到的回文串长度就保证是奇数了

考虑如果按顺序得到了 $p[1 \cdots i - 1]$ ，如何计算 $p[i]$ 的值？

如果之前有一个位置比如说是 $id$ ，有 $p[id] + id > i$ 那么 $i$ 这个位置是被覆盖了的，根据 $id$ 处的对称性，我们找 $p[id \times 2 - i]$ 延伸的部分被 $p[id]$ 延伸的部分所覆盖的那段，显然这段对称回去之后是可以从 $i$ 处延伸出去的长度。

如果找不到呢？就先让 $p[i] = 1$ 吧。

之后再暴力延伸一下。

可以证明是 $O(n)$ 的。

至于如何找是否有这么一个 $id$ 呢？递推的时候存一个 $max$ 就好了。

### 双调欧几里得旅行商问题

好像出成了某一年程设期末。

upd：其实是 [程设期末推荐练习](https://ir1d.cf/2018/06/23/cssx/程设期末推荐练习/) 里面的。

书上的提示是：从左到右扫描，对巡游路线的两个部分分别维护可能的最优解。

说的就是把回路给拆开吧。

#### 思路一

 $dp[i][j]$ 表示 $1 \cdots i$ 和 $1 \cdots j$ 两条路径。

我们可以人为要求 $1 \cdots i$ 是更快的那一条路径。

这样考虑第 $i$ 个点分给谁。

如果是分给快的那条：

 $dp[i][j] = \min(dp[i - 1][j] + dis[i - 1][i]),\ j = 1 \cdots i$ 

如果是慢的，原来是慢的那条就变成了快的，所以另一条是到 $i - 1$ 那个点：

 $dp[i][j] = \min(dp[i - 1][j] + dis[j][i]),\ j = 1 \cdots i$ 

答案是 $\min(dp[n][i] + dis[n][i])$ 。
（从一开始编号，终点是 $n$ ）

代码： <https://github.com/Ir1d/Fantasy/blob/master/openjudge/cssx/2018rec/11.cpp> 

#### 思路二

把 $dp[i][j]$ 定义反过来，不是 $1 \cdots i$ 和 $1 \cdots j$ 。

改成是 $i..n$ 和 $j \cdots n$ ，不要求哪个更快。

这样的转移更好写：

我们记 $k = \max(i, j) + 1$ 

 $k$ 这个点肯定在两条路中的一个上， $dp[i][j]$ 取两种情况的最小值即可。

 $dp[i][j] = \min(dp[i][k] + dis[k][j], dp[k][j] + dis[i][k])$ 

边界是： $dp[i][n] = dp[n][i] = dis[n][i]$ 。

答案是 $dp[1][1]$ 。

### 译码算法

 [Viterbi algorithm](https://en.wikipedia.org/wiki/Viterbi_algorithm) 之前写词性标注的时候有用到，好像用在输入法里面也是类似的。

本题中用来实现语音识别，其实就是找一条对应的概率最大的路径。

ref： <https://segmentfault.com/a/1190000008720143> 

## 参考资料与注释

[^ref1]: https://www.cnblogs.com/itlqs/p/5743114.html
